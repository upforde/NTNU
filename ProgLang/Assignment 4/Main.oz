functor
import
    System
    Application
    OS
define
    \insert Implementation.oz

%=========================== Task 1 ===========================
    {System.show {GenerateOdd ~3 10}}
    {System.show {GenerateOdd 3 3}}
    {System.show {GenerateOdd 2 2}}

    % As showed by the System.show calls, the function 
    % GenerateOdd works as described in the assignment.

%=========================== Task 2 ===========================
    {System.show {Product [1 2 3 4]}}

    % As showed by the System.show calls the function Product
    % works as described in the assignment.

%================ Disclaimer for tasks 3 and 4 ================

    % This code has been written outside of the Oz environment, 
    % meaning that the Browse function does not work. However, 
    % the code has been tested in the Oz environment to aquire
    % the results needed to answer some questions that are posed
    % in the assignment.

%=========================== Task 3 ===========================
    local Streamed Hams in
        thread Streamed = {GenerateOdd 0 1000} end
        thread Hams = {Product Streamed} end
        % {Browse Hams}
    end

    % To make the Browse statement show digits other than the 
    % full product of the entire list, one has to include a 
    % Browse statement in the product function itself, as the
    % Product function does not return anything before the entire
    % calculation is completed. After including that, the digits
    % that show up are 1, 3 and 15. This is because the first digit
    % to be multiplied is 1, after that 1 and 3 are multiplied, 
    % resulting in 3, and after that, 3 and 5 are multiplied, 
    % resulting in 15.

    % The benefit of running these two functions on sepparate threads
    % is that the calculations are happening "at the same time". The 
    % numbers are being multiplied as they are getting generated by the 
    % GenerateOdd function, or in other words, the Product function waits
    % until the next number is generated before multiplying it with the
    % previous.

%=========================== Task 4 ===========================
    local Streamed Hams in
        thread Streamed = {LazyGenerateOdd 0 1000} end
        thread Hams = {Product Streamed} end
        % {Browse Hams}
    end

    % By making GemerateOdd lazy, the hammers are produced only as the
    % consumer asks for them to be produced. This way, odd numbers are
    % only generated when needed, meaning that the consumer never gets
    % overwhelmed by the producer. The downside of this is that the 
    % throughput is decreased, as the generation stops between each 
    % element, meaning that the consumer has to wait for each element.
    
%=========================== Task 5 ===========================
% a)
    local HammerTime B in
        HammerTime = {HammerFactory}
        B = HammerTime.2.2.2.1
        {System.show HammerTime}
    end

    % As showed by the System.show HammerTime, the function 
    % HammerFactory works as described in the assignment.

% b)
    local HammerTime Consumer in
        HammerTime = {HammerFactory}
        Consumer = {HammerConsumer HammerTime 10}
        {System.show Consumer}
    end

    % After 10 seconds, the customer tells us how many hammers
    % are working

% c)
    {System.showInfo "With the buffer:"}
    local HammerTime Consumer Buffer in
        HammerTime = {HammerFactory}
        Buffer = {BoundedBuffer HammerTime 6}
        {Delay 6000}
        Consumer = {HammerConsumer Buffer 10}
        {System.show Consumer}
    end

    % When created, the bounded buffer creates a list of length N
    % of elements from the stream. These elements are retrieved from
    % the buffer by the consumer when needed. When the buffer is empty,
    % it will retrieve new elements from the stream. The delay of 6 
    % seconds is there to show that the buffer is first created and filled
    % before the consumer gets their hands on the merch. When the consumer
    % gets the buffer as a stream, they can then start counting the working
    % hammers that are in the buffer instantly, meaning that the 6 items in
    % the buffer are instantly counted. Since the consumer needs 10 hammers, 
    % the remaining four are created and counted as normal, but the operation
    % of counting all of the the working hammers has effectively only taken 
    % the consumer 4 seconds, instead of the usual 10. Compounded with the 
    % 6 second wait, the operation took the usual 10 seconds though.

    {System.showInfo "Without the buffer:"}
    local HammerTime Consumer in
        HammerTime = {HammerFactory}
        {Delay 6000}
        Consumer = {HammerConsumer HammerTime 10}
        {System.show Consumer}
    end

    % Here we see that if the buffer is removed, but the delay is still present.
    % The consumer only gets the hammers as they are produced, meaning that the
    % counting takes the usual 10 sekonds. That conpounded with the 6 second delay
    % makes this entire operation take 16 seconds.

    {Application.exit 0}
end