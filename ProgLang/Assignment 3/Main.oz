functor 
import 
    Application
    System
define
    \insert Implementations.oz

%------------------------Task 1---------------------------
    {System.showInfo "Task 1:"}
    {System.printInfo "a)"}
    local RealSol1 RealSol2 X11 X12 X21 X22 in
        {QuadraticEquation 2.0 1.0 ~1.0 RealSol1 X11 X21}
        {PrintQEAnswers RealSol1 X11 X21}

        {QuadraticEquation 2.0 1.0 2.0 RealSol2 X12 X22}
        {PrintQEAnswers RealSol2 X12 X22}
    end
    
    {System.showInfo "b)\tProcedural abstraction encloses a statement, giving it a contextual"#
    "\n\tenvironment that ensures that the statement executes the same way"#
    "\n\tevery time it is called. It allso allows for the same statement to"#
    "\n\tbe called in multiple places."}
    {System.showInfo "c)\tA function has some sort of return value (be it a value of an integer,"#
    "\n\ta tuple, a record, a function etc.) while a procedure does not."}

%------------------------Task 2---------------------------

    {System.showInfo "\nTask 2:"}
    {System.showInfo "\tThe sum of elements in list [1 2 3 4 5] is "#{Sum [1 2 3 4 5]}}
    {System.showInfo "\tThe length of list [1 2 3 4 5] is "#{Length [1 2 3 4 5]}}

%------------------------Task 3---------------------------

    {System.showInfo "\nTask 3:"}
    {System.showInfo "c)\tThe sum of elements in list [1 2 3 4 5] is "#{RightFold [1 2 3 4 5] Add 0}}
    {System.showInfo "\tThe length of list [1 2 3 4 5] is "#{RightFold [1 2 3 4 5] Len 0}}
    {System.showInfo "d)\tLeft fold would not affect the Sum and Length operations because"#
    "\n\tthese operations are commutative, meaning they are independent of"#
    "\n\torder of operations. Subtraction, however, is noncommutative, meaning"#
    "\n\tthat the order of operations does matter, which in turn means that"#
    "\n\tcalculations would be affected."}
    {System.showInfo "e)\tA good value for U when implementing multiplication is 1, because"#
    "\n\tmultiplication by 1 does not change the initial value."}

%------------------------Task 4---------------------------

    {System.showInfo "Task 4:"}
    {System.showInfo "\tf(X) equals to "#{{Quadratic 3 2 1} 2}}

%------------------------Task 5---------------------------

    {System.showInfo "Task 5:"}
    {System.showInfo "a)\tNumber generated by the LazyNumberGenerator: "#
    {{{{{{LazyNumberGenerator 0}.2}.2}.2}.2}.2}.1}
    {System.showInfo "b)\tTo me, this seemed like a simple counter object, so I implemented the"#
    "\n\tcounter showed in the book. The counter uses a cell that holds an integer."#
    "\n\tThis integer is incremented every time the Bump function is called. Instead"#
    "\n\tof returning the cell value as shown in the book, I return a new tuple lazyNum"#
    "\n\twhich holds the return value of the read function and the callable for the Bump"#
    "\n\tfunction. When {LazyNumberGenerator 0} is called, a new object is created with"#
    "\n\tthe counter being set to 0. The function returns a new tuple lazyNum which is the"#
    "\n\tsame as the one returned by the Bump function. This way, if {{LazyNumberGenerator 0}.2}.1"#
    "\n\tis called, what is happening is that the Bump function is being called first, which"#
    "\n\treturns a new tuple of the same type, and then the first value of the tuple is being"#
    "\n\taccessed, which is the value of the Read function. Read only returns the cell value,"#
    "\n\tas the task doesn't specify wether we will need to generate new values after reading"#
    "\n\tthe generated value."#
    "\n\tA limitation of this approach is the cell itself. It cannot hold infinately large "#
    "\n\tnumbers, meaning that this is not an infinate number generator. Since generating an"#
    "\n\tinfinately large number by this approach would be extremely cumbersome, I believe this"#
    "\n\tis an acceptable approach to show that I understand how lazy works. If an infinate"#
    "\n\tlist of numbers is accually needed, then I will use lazy."}

%------------------------Task 6---------------------------
    
    {System.showInfo "Task 6:"}
    {System.showInfo "a)\tMy sum function is tail recursive, as it calls the the function itself"#
    "\n\twith the tail of the list as the argument."}
    {System.showInfo "b)\tBy implementing tail recursion, the code for looping throught a list"#
    "\n\tbecomes easier to implement, less verbose and more elegang."}
    {System.showInfo "c)\tNot all languages would benefit from tail recursion, as not all languages"#
    "\n\timplement lists in the same way Oz Mozart does. Since Oz Mozart lists consist of the"#
    "\n\tfirst element (head) and the rest of the elements (tail), it's almost designed to be"#
    "\n\titterated through recursively, while other languages might implement an indexing system"#
    "\n\tthat fetches elements at the indexed position, which doesn't lend itself very well to"#
    "\n\ttail recursion."}

    {Application.exit 0}
end